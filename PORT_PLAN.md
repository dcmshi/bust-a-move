# Bust-A-Move JS Port Plan

## Constraints
- Do NOT modify the original Turing files
- Port one feature at a time
- Target: runs natively in browser (no bundler required)
- ES modules only (`import`/`export`)

---

## Architecture

### Rendering
- HTML5 Canvas, fixed `640Ã—450`
- **Two-canvas strategy:**
  - `bubbleCanvas` (offscreen) â€” bubble grid only, redrawn on land/pop
  - `mainCanvas` (visible) â€” composited each frame: background â†’ bubbleCanvas â†’ HUD â†’ shooter â†’ live bubble
  - Replaces Turing's `Pic.New(190, 90, 448, 404)` snapshot trick

### Game Loop
- `requestAnimationFrame` + state machine (replaces Turing's blocking `loop`)
- States: `LOADING â†’ INTRO â†’ INSTRUCTIONS â†’ GAME â†’ GAME_OVER / WIN`
- Each scene exports `update(dt)` and `render(ctx)`

### Input
- Event-driven listeners â†’ polled via state object (preserves Turing's polled feel)
- `keys = new Set()` populated by `keydown`/`keyup`
- `mouse = { x, y, down }` updated by `mousemove` / `mousedown` / `mouseup`

### Audio
- HTML5 `<audio>` with `loop`, one instance per track
- `playLoop(track)` / `stop()` wrapper

### Arrays
- All grid arrays converted from 1-indexed to 0-indexed
- Grid is 8 columns Ã— 12 rows

### Colour Matching
- Iterative BFS flood-fill replaces the original recursive `colourCheck` / `colourCountCheck`
- Same behaviour: find connected same-colour cluster, pop if size â‰¥ 3

### Assets
- BMP â†’ PNG (browser compatibility)
- MP3 stays as-is

---

## File Structure

```
/                        â† project root
assets/                  â† original BMP files
music/                   â† original MP3 files
turing/                  â† Bust-A-Move Bust!.t + .exe (untouched)
web/
  index.html
  assets/                â† converted PNG sprites (generated by convert-assets.js)
  src/
    main.js              â† entry point, rAF loop, scene routing
    input.js             â† keyboard + mouse state
    audio.js             â† HTML5 Audio wrapper
    assets.js            â† preload images + audio (Promise-based)
    scenes/
      intro.js           â† intro + instructions screen
      game.js            â† main game scene coordinator
      gameover.js        â† win/lose screens
    game/
      grid.js            â† hex grid math, xPos/yPos tables, snap logic
      bubble.js          â† bubble motion, wall bounce, ceiling check
      levels.js          â† all 12 level definitions
      colourCheck.js     â† BFS flood-fill match + pop logic
      ballDrop.js        â† disconnection/gravity sweep
      renderer.js        â† all canvas draw calls
```

---

## Turing â†’ JS Mapping Reference

| Turing | JavaScript |
|--------|-----------|
| `maxx = 640, maxy = 450` | Canvas `640Ã—450` |
| `setscreen("offscreenonly")` | `requestAnimationFrame` double-buffer |
| `View.Update` | end of rAF callback |
| `Pic.FileNew(file)` | `new Image()` preloaded in `assets.js` |
| `Pic.ScreenLoad(file, x, y, mode)` | `ctx.drawImage(img, x, y)` |
| `Pic.Draw(picID, x, y, mode)` | `ctx.drawImage(img, x, y)` |
| `Pic.Rotate(picID, angle, cx, cy)` | `ctx.save/translate/rotate/restore` per frame (no pre-render needed) |
| `Pic.New(x1, y1, x2, y2)` | Offscreen `bubbleCanvas` |
| `drawfillbox(x1,y1,x2,y2,c)` | `ctx.fillRect` |
| `drawbox(x1,y1,x2,y2,c)` | `ctx.strokeRect` |
| `mousewhere(mx, my, mb)` | `input.mouse.x/y/down` |
| `Input.KeyDown(chars)` | `input.keys.has('ArrowLeft')` etc. |
| `Music.PlayFileLoop(mp3)` | `audio.playLoop(track)` |
| `Music.PlayFileStop` | `audio.stop()` |
| `Rand.Int(1, 8)` | `Math.floor(Math.random() * 8) + 1` |
| `Math.Distance(x1,y1,x2,y2)` | `Math.hypot(x2-x1, y2-y1)` |
| `cosd(a)` / `sind(a)` | `Math.cos(a * Math.PI/180)` |
| `arcsind(x)` | `Math.asin(x) * 180/Math.PI` |
| `round(x)` | `Math.round(x)` |
| `type bubbleType record` | `{ x, y, c }` plain object |
| `array 1..8, 1..12 of int` | `Array(12).fill(0).map(()=>Array(8).fill(0))` (0-indexed) |
| `proc name(...)` | `function name(...)` |
| Blocking `loop` screens | State machine scenes |
| Recursive flood-fill | Iterative BFS queue |

---

## Build Order (feature by feature)

- [x] 1. `index.html` + `assets.js` â€” scaffolding + preloader
- [x] 2. `input.js` â€” keyboard + mouse state
- [x] 3. `grid.js` â€” hex grid math, coordinate tables, snap
- [x] 4. `levels.js` â€” all 12 level layouts
- [x] 5. `renderer.js` â€” canvas draw calls, shooter rotation (real-time ctx.rotate)
- [x] 6. `scenes/intro.js` â€” main menu + instructions screen
- [x] 7. `game/bubble.js` â€” bubble motion, wall, ceiling
- [x] 8. `game/colourCheck.js` â€” BFS flood-fill match + pop
- [x] 9. `game/ballDrop.js` â€” disconnection sweep
- [x] 10. `scenes/game.js` â€” game scene coordinator
- [x] 11. `audio.js` â€” music wrapper
- [x] 12. `scenes/gameover.js` â€” win/lose screens
- [x] 13. `main.js` â€” entry point, scene router, rAF loop

---

## Decisions & Notes

### Coordinate system
- Turing origin is **bottom-left** (y=0 at bottom, increases upward)
- Canvas origin is **top-left** (y=0 at top, increases downward)
- Conversion for Turing `Pic.Draw(img, tx, ty)` â†’ canvas: `ctx.drawImage(img, tx, 450 - ty - img.height)`
- `ty(turingY)` helper in `input.js` converts mouse Y for hit-testing: `449 - turingY`
- All grid coordinates in `grid.js` (`CELL_CENTERS`) are already in **canvas space**

### Shooter rotation
- Turing pre-rendered 180 rotated images for performance (2007 hardware)
- JS port uses `ctx.save/translate/rotate/restore` per frame â€” trivially fast at 60fps
- Rotation pivot in image: `(cx=63, cy=img.height-59)` (cy=59 was from bottom in Turing)
- `ctx.rotate((90 - ang) * Math.PI / 180)` â€” ang=90 is straight up, no rotation needed; sign is flipped relative to Turing because canvas ctx.rotate is CW-positive while Turing Pic.Rotate is CCW-positive

### BMP transparency
- Original uses `picMerge` mode which treats the background colour as transparent
- **Resolved:** `convert-assets.js` (project root) converts bubble + shooter BMPs to PNG using the top-left pixel as the colour key. Run once: `npm install jimp && node convert-assets.js`
- Output goes to `web/assets/*.png`; `assets.js` already references these paths
- Other sprites (backgrounds, HUD frames, full-screen images) are left as BMP â€” they don't need transparency

### Bubble canvas
- `ballBackground := Pic.New(190, 90, 448, 404)` in Turing â†’ offscreen `bubbleCanvas` (full 640Ã—450)
- Redrawn only when a bubble lands, pops, or drops â€” not every frame
- Composited over background via `ctx.drawImage(bubbleCanvas, 0, 0)`

### Audio autoplay
- Browsers block audio until first user gesture
- Intro screen click (Play button) serves as the first gesture â€” audio starts there
- `audio.js` must handle graceful no-op if a track hasn't been interacted with yet

### Colour matching (known bug in original)
- The recursive `colourCheck` / `colourCountCheck` in the original has a known bug
- JS port uses iterative BFS flood-fill in `colourCheck.js` â€” cleaner and bug-free
- Unit tests planned for edge cases (corners, ceiling row, odd/even row adjacency)

### Level 2
- Contains a random column â€” `fillLevel(2, grid)` re-randomises on each call
- This means retrying level 2 after losing a life gives a new layout (matches original behaviour)

### Active bubble position
- Stored as **canvas-space centre** `{ x, y }` throughout the JS port
- Turing stored bottom-left in its y-up space; initial position `(302, 39)` in Turing = canvas centre `(318, 395)`
- Wall bounds (canvas x): left wall â‰¤ 206, right wall â‰¥ 436 (centre coords, verified against source)
- Ceiling (canvas y): â‰¤ 64

---

## Post-Port Fixes & Features

### Shooter rotation fix
- Initial port used `(ang - 90)` â€” wrong sign; shooter pointed opposite to bullet direction
- Fix: `(90 - ang) * Math.PI / 180` â€” canvas `ctx.rotate` is CW-positive, Turing `Pic.Rotate` is CCW-positive

### Arrow key direction fix
- Turing's original key mapping: left arrow â†’ `ang -= 1`, right arrow â†’ `ang += 1`
- With the corrected rotation formula this felt inverted to the player
- Fix: swapped to left â†’ `ang += 1` (CCW, toward 150Â°), right â†’ `ang -= 1` (CW, toward 30Â°)

### Level-aware bubble colours
- `randColorId()` calls moved inside `loadLevel()` so colours are always picked after `fillLevel()` populates the grid
- Covers all three paths: initial game start, level advance, and life-loss restart
- Falls back to 1â€“8 if the grid is empty (mid-level-transition edge case)

### Transparent sprites (`convert-assets.js`)
- Pure Node.js script (no npm needed): reads BMPs, keys out a corner pixel colour, writes PNGs to `web/assets/`
- Converted sprites: all 8 bubbles, shooter, gun, man, next (bottom-right key), play, what, back
- `assets.js` references `assets/*.png` for all converted sprites; remaining UI assets still use `../` BMP paths
- Run: `node convert-assets.js` from the project root; generated PNGs are committed to the repo

### Volume / mute controls
- Semi-transparent overlay (top-left of canvas): mute toggle button (ðŸ”Š/ðŸ”‡) + volume slider
- Default volume: 30%
- `audio.js` exports `setVolume(v)`, `setMuted(bool)`, `getVolume()`, `getMuted()`; volume applied on every `playLoop`/`playOnce` call

### Autoplay unlock
- Browser autoplay policy blocks audio until first user gesture
- `audio.js` registers permanent `pointerdown`/`keydown` listeners on `document` that retry the pending track on first interaction
- Music starts on first click anywhere on the page (loading overlay, canvas, outside canvas)
