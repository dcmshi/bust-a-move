/**
 * assets.js
 * Preloads all images and audio. Paths are relative to index.html (web/).
 * Original BMP/MP3 files live in the project root, referenced via '../'.
 *
 * Audio rename map (original → key used here):
 *   Hellogoodbye - Shimmy Shimmy Quarter Turn.mp3  → audio.intro
 *   The Postal Service - Such Great Heights.mp3     → audio.track1
 *   royksopp - Remind Me.mp3                        → audio.track2
 *   hellogoodbye - here (in your arms).mp3          → audio.track3
 *   Techno - Sand Storm.mp3                         → audio.track4
 *   Hot Hot Heat - Talk to Me, Dance With Me.mp3    → audio.win
 *   Plain White T's.mp3                             → audio.lose
 */

// Manifest entries are either a plain src string, or { src, fallback } where
// fallback is tried automatically if the primary src 404s.  This lets the
// bubbles and shooter use transparent PNGs (generated by convert-assets.js)
// while gracefully falling back to the original BMPs before that script is run.
const IMAGE_MANIFEST = {
  // UI
  mainTitle:    '../mainTitle.bmp',
  play:         '../play.bmp',
  what:         '../what.bmp',
  back:         '../back.bmp',
  instructions: '../instructions.bmp',
  next:         '../next.bmp',
  man:          '../man.bmp',
  // Shooter — transparent PNG, falls back to BMP
  shooter:      { src: 'assets/shooter.png',      fallback: '../shooter.bmp' },
  gun:          '../gun.bmp',
  // Lives HUD
  life1:        '../life1.bmp',
  life2:        '../life2.bmp',
  life3:        '../life3.bmp',
  // Backgrounds
  bg1:          '../levelbackground.bmp',
  bg2:          '../levelbackground2.bmp',
  bg3:          '../levelbackground3.bmp',
  bg4:          '../levelbackground4.bmp',
  // Game over screens
  gameover:     '../gameover.bmp',
  gameover2:    '../gameover2.bmp',
  // Bubbles — transparent PNGs, each falls back to original BMP
  bubble1:      { src: 'assets/bluebubble.png',   fallback: '../bluebubble.bmp' },
  bubble2:      { src: 'assets/greenbubble.png',  fallback: '../greenbubble.bmp' },
  bubble3:      { src: 'assets/greybubble.png',   fallback: '../greybubble.bmp' },
  bubble4:      { src: 'assets/orangebubble.png', fallback: '../orangebubble.bmp' },
  bubble5:      { src: 'assets/purplebubble.png', fallback: '../purplebubble.bmp' },
  bubble6:      { src: 'assets/yellowbubble.png', fallback: '../yellowbubble.bmp' },
  bubble7:      { src: 'assets/redbubble.png',    fallback: '../redbubble.bmp' },
  bubble8:      { src: 'assets/whitebubble.png',  fallback: '../whitebubble.bmp' },
};

const AUDIO_MANIFEST = {
  intro:   '../Hellogoodbye - Shimmy Shimmy Quarter Turn.mp3',
  track1:  '../The Postal Service - Such Great Heights.mp3',
  track2:  '../royksopp - Remind Me.mp3',
  track3:  '../hellogoodbye - here (in your arms).mp3',
  track4:  '../Techno - Sand Storm.mp3',
  win:     '../Hot Hot Heat - Talk to Me, Dance With Me.mp3',
  lose:    "../Plain White T's.mp3",
};

export const images = {};
export const audio  = {};

function loadImage(key, src) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload  = () => { images[key] = img; resolve(); };
    img.onerror = () => { console.warn(`[assets] missing: ${src}`); resolve(); };
    img.src = src;
  });
}

/**
 * Load an image, falling back to `fallback` src if the primary 404s.
 * Used for PNG sprites that may not exist yet (before convert-assets.js is run).
 */
function loadImageWithFallback(key, src, fallback) {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload  = () => { images[key] = img; resolve(); };
    img.onerror = () => {
      // Primary (PNG) failed — try the original BMP
      const fb = new Image();
      fb.onload  = () => { images[key] = fb; resolve(); };
      fb.onerror = () => { console.warn(`[assets] missing: ${src} and ${fallback}`); resolve(); };
      fb.src = fallback;
    };
    img.src = src;
  });
}

function loadAudio(key, src) {
  // Audio is non-blocking — browser autoplay policy means we can't verify
  // playback readiness until after the first user gesture anyway.
  const el = new Audio();
  el.preload = 'auto';
  el.loop    = false; // controlled by audio.js
  el.src     = src;
  audio[key] = el;
}

/**
 * Preload all assets. Calls onProgress(0–1) as images finish loading.
 * Audio elements are created immediately but not awaited.
 * @param {(progress: number) => void} [onProgress]
 */
export async function loadAll(onProgress) {
  const entries = Object.entries(IMAGE_MANIFEST);
  let loaded = 0;

  // Set up audio elements synchronously (no await needed)
  for (const [key, src] of Object.entries(AUDIO_MANIFEST)) {
    loadAudio(key, src);
  }

  // Await all images — entries may be a plain src string or { src, fallback }
  await Promise.all(
    entries.map(([key, entry]) => {
      const job = typeof entry === 'string'
        ? loadImage(key, entry)
        : loadImageWithFallback(key, entry.src, entry.fallback);
      return job.then(() => {
        loaded++;
        onProgress?.(loaded / entries.length);
      });
    })
  );
}

/** Get bubble image by Turing colour ID (1–8). */
export function getBubbleImage(colourId) {
  return images[`bubble${colourId}`];
}

/**
 * Get background image for a given level (1–12).
 * Pattern mirrors the original: bg2, bg3, bg4, bg1, bg2, bg3, bg4, bg1 …
 */
export function getBackground(level) {
  const cycle = ['bg2', 'bg3', 'bg4', 'bg1'];
  return images[cycle[(level - 1) % 4]];
}
